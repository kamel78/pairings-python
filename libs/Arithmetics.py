import gmpy2 as gmp
from itertools import chain

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
tobytes = lambda a,p:list(bytes(int(a).to_bytes((int(p).bit_length() + 7) // 8, 'little')))
frombytes = lambda l:int.from_bytes(bytes(l),'little')
def tobytearray(x,p):return list(chain(*([tobytes(len((_:=[tobytes(i,p) for i in x])[0]),(2**16)-1)]+_ )))                
def frombytearray(x):return [frombytes(x[2:][i*(num:=frombytes(x[:2])):(i+1)*num]) for i in range((len(x)-2)//frombytes(x[:2]))]

#------------------------ Convert integer to binary representation ---------------------------------------------------------------------------------------------------------#
def tobin(x,order = "down"):return [abs(x) >> i & 1 for i in range(0, x.bit_length())] if order=="up" else list(reversed([abs(x) >> i & 1 for i in range(0, x.bit_length())]))

#----------------------- Convert integer to Non-Adjacent negative representation -------------------------------------------------------------------------------------------#
def tonaf(x,order = "down"):
      b  = abs(x)
      xh = (b >> 1)
      a  = b + xh
      b  = (b >> 1) ^ a
      np , nm = a & b, xh & b
      return [(np >> i & 1) - (nm >> i & 1) for i in range(0, np.bit_length())] if order=="up" else list(reversed([(np >> i & 1) - (nm >> i & 1) for i in range(0, np.bit_length())]))

#---------------------- Convert integer low hamming weight representation bin/naf ------------------------------------------------------------------------------------------#
def bestrepr(x,order = "up"):
        _1 = tobin(x,order)
        _2 = tonaf(x,order)
        if _1.count(0)>=_2.count(0):return _1,0        
        else :return _2,1       

#----------------------- Invert an integer modulo p ------------------------------------------------------------------------------------------------------------------------#
def invert(x,p):return gmp.invert(x,p)

#---------------------- Residual square root modulo p ----------------------------------------------------------------------------------------------------------------------#
def rsqrt(x,p):
      if p & 3 ==3:
           _  = pow(x,(p+1)>>2,p) 
           __ =((_**2)*pow(x,-1,p)) % p
           if __ != 1: return None ## Check if 'x' is a quadratic Residu modulo p using Euler's Criterion
           else: return _
      else:   ## If the Modulo is in the form 4k+1, we use the Tonelli-Shanks Algorithm         
        if pow(x,(p-1)>>1,p)!=1:return None
        else:         
          g = gmp.xmpz(2)
          while (pow(g,(p-1)>>1,p)!=p-1):g+=1
          e1,e2 = (p-1)>>1,gmp.xmpz(0)
          while (e1 & 1==0):
              e1 >>= 1
              e2 >>= 1
              if (pow(x,e1,p)*pow(g,e2,p)) % p == p-1:e2 = e2 + ((p-1)>>1)
          return pow(x,(e1+1)>>1,p) * pow(g,e2>>1,p)

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#                                                           Arithmetic over Fp2         
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#                              
#------------------------- Multiplication over Fp2  ------------------------------------------------------------------------------------------------------------------------#
def _mulFp2(x,y):
    if (type(y)==int)or(type(y)==gmp.mpz):return [y*x[0], y*x[1]]
    else: 
         v0 = x[0] * y[0]
         v1 = x[1] * y[1]
    return  [v0-v1,(x[0] + x[1]) * (y[0] + y[1]) - v0 - v1]

#------------------------ Square over Fp2  ---------------------------------------------------------------------------------------------------------------------------------#
def _sqrFp2(x):return [(x[0]**2) - (x[1]**2), (x[0] * x[1]) << 1] 

#----------------------- Inversion over Fp2  -------------------------------------------------------------------------------------------------------------------------------#
def _invFp2(x,p):
   t = gmp.invert((x[0] * x[0] + x[1] * x[1]),p)
   return [x[0] * t,-x[1] * t]       

#----------------------- Residual square root over Fp2 ---------------------------------------------------------------------------------------------------------------------#
def _sqrtFp2(x,p,inv2):
    rootdelta = rsqrt((x[0] * x[0] + x[1] * x[1]) % p, p)
    if (rootdelta is None):return None
    else:
        t1 = (x[0] + rootdelta) * inv2
        a = rsqrt(t1,p)
        if a is None:
          
          t1 = t1 - rootdelta
          
          a = rsqrt(t1,p)
          if a is None:
            t1 = -t1
            a = rsqrt(t1,p)
            if a is None:
              t1 = t1-rootdelta
              a = rsqrt(t1,p)
        if a is None:return None
        else:
          if a==0:return [0,0]
          else:return [a,x[1] * pow((2 * a),-1, p)]

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#                                                           Arithmetic over Fp6         
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#------------------------- Multiplication over Fp6  ------------------------------------------------------------------------------------------------------------------------#
def _mulFp6(x,y):          
  if (type(y)==int)or(type(y)==gmp.mpz):return  [y * x[0],y * x[1],y * x[2],y * x[3],y * x[4],y * x[5]]
  else:
      if (y==[0,0,1,0,0,0]):return  [(x[4] - x[5]),(x[4] + x[5])] + x[:4]
      else :
            _0,_1 = x[0] * y[0],x[1] * y[1]
            t0 = [_0 - _1,((x[0] + x[1]) * (y[0] + y[1]) - _0 - _1)]
            _0,_1 = x[2] * y[2], x[3] * y[3]
            t1 = [_0 - _1,((x[2] + x[3]) * (y[2] + y[3]) - _0 - _1)]
            _0,_1 = x[4] * y[4],x[5] * y[5]
            t2 = [_0 - _1,((x[4] + x[5]) * (y[4] + y[5]) - _0 - _1)]
            _0,_1 = [x[2] + x[4],x[3] + x[5]],[y[2] + y[4],y[3] + y[5]]
            __0,__1 = _0[0] * _1[0], _0[1] * _1[1]
            _ = [(__0 - __1 - t1[0] - t2[0]),((_0[0] + _0[1]) * (_1[0] + _1[1]) - __0 - __1 - t1[1] - t2[1])]
            _00 = [(_[0] - _[1]) + t0[0],(_[0] + _[1]) + t0[1]]
            _0,_1 = [x[0] + x[2],x[1] + x[3]],[y[0] + y[2],y[1] + y[3]]
            __0,__1 = _0[0] * _1[0], _0[1] * _1[1]
            _ = [__0 - __1 - t0[0] -t1[0],(_0[0] + _0[1]) * (_1[0] + _1[1]) - __0 - __1 - t0[1] - t1[1]]
            _01 = [_[0] + (t2[0] - t2[1]),_[1] + (t2[0] + t2[1])]
            _0,_1 = [x[0] + x[4],x[1] + x[5]],[y[0] + y[4],y[1] + y[5]]
            __0,__1 = _0[0] * _1[0],_0[1] * _1[1]
            _02 = [__0 - __1 - t0[0] - t2[0] + t1[0],(_0[0] + _0[1]) * (_1[0] + _1[1]) - __0 -__1 - t0[1] - t2[1] + t1[1]]           
            return _00 + _01 + _02        

#------------------------ Square over Fp6  ---------------------------------------------------------------------------------------------------------------------------------#
def _sqrFp6(x): 
          _0,_1 = x[0]**2, x[1]**2
          t0 = [_0 - _1,((x[0] + x[1])**2 - _0 - _1)]
          _0,_1 = x[2]**2, x[3]**2
          t1 = [_0 - _1,((x[2] + x[3])**2 - _0 - _1)]
          _0,_1 = x[4]**2, x[5]**2
          t2 = [_0 - _1,((x[4] + x[5])**2 - _0 - _1)]
          _0 = [x[2] + x[4],x[3] + x[5]]
          __0,__1 = _0[0]**2, _0[1]**2
          _ = [(__0 - __1 - t1[0] - t2[0]),((_0[0] + _0[1])**2 - __0 - __1 - t1[1] - t2[1])]
          _00 = [(_[0] - _[1]) + t0[0] ,(_[0] + _[1]) + t0[1]]
          _0 = [x[0] + x[2],x[1] + x[3]]
          __0,__1 = _0[0]**2, _0[1]**2
          _ = [__0 - __1 - t0[0] - t1[0],(_0[0] + _0[1])**2 - __0 - __1 - t0[1] - t1[1]]
          _01 = [_[0] + (t2[0] - t2[1]),_[1] + (t2[0] + t2[1])]
          _0 = [x[0] + x[4],x[1] + x[5]]
          __0,__1 = _0[0]**2, _0[1]**2
          _02 = [__0 - __1 - t0[0] - t2[0] + t1[0],(_0[0] + _0[1])**2 - __0 - __1 - t0[1] - t2[1] + t1[1]]           
          return _00+_01+_02

#----------------------- Inversion over Fp6  -------------------------------------------------------------------------------------------------------------------------------#
def _invFp6(x,p):
        _0,_1 = x[2] * x[4],x[3] * x[5]
        __0,__1 = _0 - _1,(x[2] + x[3]) * (x[4] + x[5]) - _0 - _1
        _t00,_t01 = x[0] ** 2 - x[1] ** 2 - (__0 - __1),((x[0] * x[1])<<1) - (__0 + __1) 
        _0,_1 = x[0] * x[2],x[1] * x[3]
        __0,__1 = _0 - _1,(x[0] + x[1]) * (x[2] + x[3]) - _0 - _1
        _1 = [x[4] ** 2 - x[5] ** 2,(x[4] * x[5])<<1] 
        _t10,_t11 = (_1[0] - _1[1]) - __0,(_1[0] + _1[1]) - __1
        _0,_1 = x[0] * x[4],x[1] * x[5]
        __0,__1 = _0 - _1,(x[0] + x[1]) * (x[4] + x[5]) - _0 - _1
        _t20,_t21 = x[2] ** 2 - x[3] ** 2 - __0,((x[2] * x[3])<<1) - __1 
        _0,_1 = x[0] * _t00,x[1] * _t01
        _x1 = _0 - _1,(x[0] + x[1]) * (_t00 + _t01) - _0 - _1
        _0,_1 = x[4] * _t10,x[5] * _t11
        _x2 = _0 - _1,(x[4] + x[5]) * (_t10 + _t11) - _0 - _1
        _0,_1 = x[2] * _t20,x[3] * _t21
        _x3 = _0 - _1,(x[2] + x[3]) * (_t20 + _t21) - _0 - _1
        _t0,_t1 = _x2[0] + _x3[0],_x2[1] + _x3[1]
        _t30,_t31 = (_t0 - _t1) + _x1[0],(_t0 + _t1) + _x1[1]
        _t = gmp.invert(_t30 ** 2 + _t31 ** 2,p)
        t0,t1 = _t30 * _t , - _t31 * _t 
        _0,_1,_2,_3,_4,_5 = _t00 * t0,_t01 * t1,_t10 * t0,_t11 * t1,_t20 * t0,_t21 * t1        
        return [_0 - _1,(_t00 + _t01) * (t0 + t1) - _0 - _1 ,_2 - _3,(_t10 + _t11) * (t0 + t1) - _2 - _3,_4 - _5,(_t20 + _t21) * (t0 + t1) - _4 - _5]

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#                                                           Arithmetic over Fp12         
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#------------------------- Karabina's compressed square over cyclotomic sub-field for Fp12 ---------------------------------------------------------------------------------#
def _sqrCompressFp12(x):   
            t0 = [(x[2] ** 2) - (x[3] ** 2),(x[2] * x[3])<<1]             
            t1 = [(x[10] ** 2) - (x[11] ** 2),(x[10] * x[11])<<1] 
            t3 = [(x[6] ** 2) - (x[7] ** 2),(x[6] * x[7])<<1] 
            t4 = [(x[4] ** 2) - (x[5] ** 2),(x[4] * x[5])<<1] 
            _ = [x[2] + x[10],x[3] + x[11]]
            t5 = [3 * ((_[0] ** 2 - _[1] ** 2) - t0[0] - t1[0]),3 * (((_[0] * _[1])<<1) - t0[1] - t1[1])]
            _ = [x[4] + x[6],x[5] + x[7]]
            return [0,0,\
                        3 * (t4[0] - t4[1] + t3[0]) - (x[2]<<1),3 * (t4[0] + t4[1] + t3[1]) - (x[3]<<1),   \
                        3 * (t1[0] - t1[1] + t0[0]) - (x[4]<<1),3 * (t1[0] + t1[1] + t0[1]) - (x[5]<<1),   \
                        t5[0] - t5[1] + (x[6]<<1),t5[0] + t5[1] + (x[7]<<1),   \
                        0,0, \
                        3 * ((_[0] ** 2 - _[1] ** 2) - t3[0] - t4[0]) + (x[10]<<1),3 * (((_[0] * _[1])<<1) - t3[1] - t4[1]) + (x[11]<<1)]

#------------------------- Karabina's square decompression over cyclotomic sub-field for Fp12 ------------------------------------------------------------------------------#
def _sqrDecompressFp12(x,_basefield):
                      if (x[6] == 0)&(x[7] == 0):
                        t0 = [3 * ((_0:= x[4] * x[2]) - (_1:= x[5] * x[3])),3 * ((x[2] + x[3]) * (x[4] + x[5] - _0 - _1))]     
                        t = gmp.invert((x[4] * x[4] + x[5] * x[5]),_basefield)
                        return [((x[8] ** 2 - x[9] ** 2) << 1) - t0[0] + t0[1] + 1 ,((x[8] * x[9]) << 1) - t0[0] - t0[1], \
                                    x[2],x[3], \
                                    x[4],x[5], \
                                    x[6],x[7], \
                                    (((_0:= x[2] * x[10]) - (_1:= x[3] * x[11])) << 1) * x[4] * t,(((x[2] + x[3]) * (x[10] + x[11]) - _0 - _1) << 1) * ( - x[5] * t), \
                                    x[10],x[11]
                                      ]
                      else:
                        _ = [x[10] ** 2 - x[11] ** 2,(x[10] * x[11]) << 1]
                        t = gmp.invert((x[6] << 2) ** 2 + (x[7] << 2) ** 2,_basefield)
                        _x1 = [(x[6] << 2) * t, - (x[7] << 2) * t]
                        _x2 = [(3 * (x[2] ** 2 - x[3] ** 2) + _[0] - _[1] - (x[4] << 1)),(6 * (x[2] * x[3]) + _[0] + _[1] - (x[5] << 1))]               
                        rbb = [(_0:= _x1[0] * _x2[0]) - (_1:= _x1[1] * _x2[1]),(_x1[0] + _x1[1]) * (_x2[0] + _x2[1]) - _0 - _1]
                        _x1 = [(_0:= x[4] * x[2]) - (_1:= x[5] * x[3]),(x[2] + x[3]) * (x[4] + x[5]) - _0 - _1]  
                        _ = [((rbb[0] ** 2 - rbb[1] ** 2) << 1) + ((_0:= x[6] * x[10]) - (_1:= x[7] * x[11])) - 3 * _x1[0],\
                             ((rbb[0] * rbb[1]) << 2) + ((x[6] + x[7]) * (x[10] + x[11]) - _0 - _1) - 3 * _x1[1]]
                        return [_[0] - _[1] + 1,_[0] + _[1],\
                                    x[2],x[3], \
                                    x[4],x[5], \
                                    x[6],x[7], \
                                    rbb[0],rbb[1], \
                                    x[10],x[11] ]

#-------------------------- Scott's square over cyclotomic sub-field for Fp12 --------------------------------------------------------------------------------------------#
def _unisqrFp12(x):
    x00,x01 = x[0] ** 2 - x[1] ** 2,(x[0] * x[1]) << 1
    x10,x11 = x[8] ** 2 - x[9] ** 2,(x[8] * x[9]) << 1    
    _x0,_x1 = x[0] + x[8],x[1] + x[9]
    y00,y01 = x[2] ** 2 - x[3] ** 2,(x[2] * x[3]) << 1
    y10,y11 = x[10] ** 2 - x[11] ** 2,(x[10] * x[11]) << 1    
    _y0,_y1 = x[2] + x[10],x[3] + x[11]
    z00,z01 = x[6] ** 2 - x[7] ** 2,(x[6] * x[7]) << 1
    z10,z11 = x[4] ** 2 - x[5] ** 2,(x[4] * x[5]) << 1    
    _z0,_z1 = x[6] + x[4],x[7] + x[5]    
    return [3 * (x00 + (x10 - x11)) - (x[0] << 1),3 * (x01 + (x10 + x11)) - (x[1] << 1), 3 * (z00 + (z10 - z11)) - (x[2] << 1),3 * (z01 + (z10 + z11)) - (x[3] << 1),
                 3 * (y00 + (y10 - y11)) - (x[4] << 1),3 * (y01 + (y10 + y11)) - (x[5] << 1),
                 3 * ((_y0 ** 2 - _y1 ** 2 - y00 - y10) -  (((_y0 * _y1) << 1) - y01 - y11)) + (x[6] << 1),
                 3 * ((((_y0 * _y1) << 1) - y01 - y11) + (_y0 ** 2 - _y1 ** 2 - y00 - y10)) + (x[7] << 1), 
                 3 * (_x0 ** 2 - _x1 ** 2 - x00 - x10) + (x[8] << 1),3 * (((_x0 * _x1) << 1) - x01 - x11) + (x[9] << 1),
                 3 * (_z0 ** 2 - _z1 ** 2 - z00 - z10) + (x[10] << 1),3 * (((_z0 * _z1) << 1) - z01 - z11) + (x[11] << 1) ]

#------------------------ Multiplication over Fp12  -----------------------------------------------------------------------------------------------------------------------#
def _mulFp12(x,y):
    if (type(y) == int)or(type(y) == gmp.mpz):return [y * x[0],y * x[1],y * x[2],y * x[3],y * x[4],y * x[5],y * x[6],y * x[7],y * x[8],y * x[9],y * x[10],y * x[11]]
    if (y == [0,0,0,0,0,0,1,0,0,0,0,0]):return [x[10] - x[11],x[10] + x[11]] + x[6:10]  + x[:6]
    else :
      t0 = _mulFp6(x[:6],y[:6])
      t1 = _mulFp6(x[6:],y[6:])
      t3 = _mulFp6([x[0] + x[6],x[1] + x[7],x[2] + x[8],x[3] + x[9],x[4] + x[10],x[5] + x[11]],[y[0] + y[6],y[1] + y[7],y[2] + y[8],y[3] + y[9],y[4] + y[10],y[5] + y[11]])
      return [(t1[4] - t1[5]) + t0[0],(t1[4] + t1[5]) + t0[1],(t1[0] + t0[2]),(t1[1] + t0[3]),t1[2] + t0[4],t1[3] + t0[5]] + \
             [t3[0] - t0[0] - t1[0],t3[1] - t0[1] - t1[1],t3[2] - t0[2] - t1[2],t3[3] - t0[3] - t1[3],t3[4] - t0[4] - t1[4],t3[5] - t0[5] - t1[5]]

#------------------------ Square over Fp12  ---------------------------------------------------------------------------------------------------------------------------------#
def _sqrFp12(x):
    t0 = _sqrFp6(x[:6])
    t1 = _sqrFp6(x[6:])
    t3 = _sqrFp6([x[0] + x[6],x[1] + x[7],x[2] + x[8],x[3] + x[9],x[4] + x[10],x[5] + x[11]])
    return [t1[4] - t1[5] + t0[0],t1[4] + t1[5] + t0[1],t1[0] + t0[2],t1[1] + t0[3],t1[2] + t0[4],t1[3] + t0[5]] + \
           [t3[0] - t0[0] - t1[0],t3[1] - t0[1] - t1[1],t3[2] - t0[2] - t1[2],t3[3] - t0[3] - t1[3],t3[4] - t0[4] - t1[4],t3[5] - t0[5] - t1[5]]       

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#                                                           Arithmetic over Fp4        
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#------------------------ Multiplication over Fp4 --------------------------------------------------------------------------------------------------------------------------#
def _mulFp4(x,y):
  if (type(y) == int)or(type(y) == gmp.mpz):return [y * x[i] for i in range(4)]
  if (y == [1,1,0,0]):return  [(x[2] - x[3]),(x[2] + x[3])] + x[:2] 
  else :
      _0,_1 = x[0] * y[0],x[1] * y[1]
      t0 = [_0 - _1,((x[0] + x[1]) * (y[0] + y[1]) - _0 - _1)]
      _0,_1 = x[2] * y[2],x[3] * y[3]
      t1 = [_0 - _1,((x[2] + x[3]) * (y[2] + y[3]) - _0 - _1)]
      _0,_1,_2,_3 = (x[0] + x[2]),(y[0] + y[2]),(x[1] + x[3]),(y[1] + y[3])
      __0,__1 = _0 * _1,_2 * _3
      return [(t0[0] + (t1[0] - t1[1])),(t0[1] + (t1[0] + t1[1])), __0 - __1 - t0[0] - t1[0],((_0 + _2) * (_1 + _3) - __0 - __1 - t0[1] - t1[1])]
      
#------------------------ Square over Fp4  -------------------------------------------------------------------------------------------------------------------------------#
def _sqrFp4(x):
  t0 = [x[0] ** 2 - x[1] ** 2,(x[0] * x[1])<<1]
  t1 = [x[2] ** 2 - x[3] ** 2,(x[2] * x[3])<<1]
  _0,_1 = x[0] + x[2],x[1] + x[3]
  return [(t0[0] + (t1[0] - t1[1])),(t0[1] + (t1[0] + t1[1])),_0 ** 2 - _1 ** 2 - t0[0] - t1[0],((_0 * _1)<<1) - t0[1] - t1[1]]

#------------------------ Inversion over Fp4  ----------------------------------------------------------------------------------------------------------------------------#
def _invFp4(x,p):
 _1 = [x[2] ** 2 - x[3] ** 2,(x[2] * x[3])<<1] 
 _0 = [x[0] ** 2 - x[1] ** 2,(x[0] * x[1])<<1] 
 t = [_0[0] - (_1[0] - _1[1]),_0[1] - (_1[0] + _1[1])]
 _t = gmp.invert(t[0] ** 2 + t[1] ** 2,p)
 t = [t[0] * _t , - t[1] * _t ]
 _0,_1,_2,_3 = x[0] * t[0],x[1] * t[1],x[2] * t[0],x[3] * t[1]        
 return [_0 - _1,(x[0] + x[1]) * (t[0] + t[1]) - _0 - _1 ,_3 - _2,_2 + _3 - (x[2] + x[3]) * (t[0] + t[1])]

#------------------------ Residual square root over Fp4 ------------------------------------------------------------------------------------------------------------------#
def _sqrtFp4(x,p,inv2):
    _1 = [x[2] ** 2 - x[3] ** 2,(x[2] * x[3])<<1] 
    _0 = [x[0] ** 2 - x[1] ** 2,(x[0] * x[1])<<1]         
    rootdelta = _sqrtFp2([_0[0] - (_1[0] - _1[1]),_0[1] - (_1[0] + _1[1])],p,inv2)    
    if rootdelta is None:return None
    else:
      t = [(rootdelta[0] + x[0]) * inv2,(rootdelta[1] + x[1]) * inv2]
      r = _sqrtFp2(t,p,inv2)
      if r is None:
        t = [t[0] - rootdelta[0],t[1] - rootdelta[1]]
        r = _sqrtFp2(t,p,inv2)
        if r is None:
              t = [ - t[0], - t[1]]
              r = _sqrtFp2(t,p,inv2)
              if r is None:
                t = [t[0] - rootdelta[0],t[1] - rootdelta[1]]
                r = _sqrtFp2(t,p,inv2)
      if r == [0,0]:return [0,0,0,0]
      else:
         t = gmp.invert(((((r[0]<<1) ** 2)) + ((r[1]<<1) ** 2)),p)
         _1,_2, = (r[0] * t)<<1,( - r[1] * t)<<1
         v0,v1 = x[2] * _1,x[3] * _2
         return r + [v0 - v1,(x[2] + x[3]) * (_1 + _2) - v0 - v1]

#------------------------ Conjugate over Fp4 ---------------------------------------------------------------------------------------------------------------------------#
def _conjugateFp4(x):
    return [x[0],x[1], - x[2], - x[3]]

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#                                                           Arithmetic over Fp8        
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#------------------------ Multiplication over Fp8 --------------------------------------------------------------------------------------------------------------------------#
def _mulFp8(x,y):
    if (type(y) == int)or(type(y) == gmp.mpz):return [y * x[0],y * x[1],y * x[2],y * x[3],y * x[4],y * x[5],y * x[6],y * x[7]]
    if (y == [0,0,0,0,1,0,0,0]):return [x[6] - x[7],x[6] + x[7]]  + x[4:6] + x[:4]
    else :
      t0 = _mulFp4(x[:4],y[:4])
      t1 = _mulFp4(x[4:],y[4:])
      t3 = _mulFp4([x[0] + x[4],x[1] + x[5],x[2] + x[6],x[3] + x[7]],[y[0] + y[4],y[1] + y[5],y[2] + y[6],y[3] + y[7]])
      return [(t1[2] - t1[3]) + t0[0],(t1[2] + t1[3]) + t0[1],t1[0] + t0[2],t1[1] + t0[3]] + [t3[0] - t0[0] - t1[0],t3[1] - t0[1] - t1[1],t3[2] - t0[2] - t1[2],t3[3] - t0[3] - t1[3]]

#------------------------ Square over Fp8 ----------------------------------------------------------------------------------------------------------------------------------#
def _sqrFp8(x):
  t0 = _sqrFp4(x[:4])
  t1 = _sqrFp4(x[4:])
  t3 = _sqrFp4([x[0] + x[4],x[1] + x[5],x[2] + x[6],x[3] + x[7]])
  return [t1[2] - t1[3] + t0[0],t1[2] + t1[3] + t0[1],t1[0] + t0[2],t1[1] + t0[3]] + [t3[0] - t0[0] - t1[0],t3[1] - t0[1] - t1[1],t3[2] - t0[2] - t1[2],t3[3] - t0[3] - t1[3]]

#------------------------ Inversion over Fp8 -------------------------------------------------------------------------------------------------------------------------------#
def _invFp8(x,p):
  _0 = _sqrFp4(x[:4])
  _1 = _sqrFp4(x[4:])
  _ = _invFp4([_0[0] - (_1[2] - _1[3]),_0[1] - (_1[2] + _1[3]),_0[2] - _1[0],_0[3] - _1[1]],p)
  _0 = _mulFp4(x[:4],_)
  _1 = _mulFp4(x[4:],_)
  return _0 + [ - _1[0], - _1[1], - _1[2], - _1[3]]

#------------------------ Residual square root over Fp8 --------------------------------------------------------------------------------------------------------------------#
def _sqrtFp8(x,p,inv2):
  _0 = _sqrFp4(x[:4])
  _1 = _sqrFp4(x[4:])
  _ = [_0[0] - (_1[2] - _1[3]),_0[1] - (_1[2] + _1[3]),_0[2] - _1[0],_0[3] - _1[1]]
  rootdelta = _sqrtFp4(_,p,inv2)    
  if rootdelta is None:return None
  else:
    t = [(rootdelta[0] + x[0]) * inv2,(rootdelta[1] + x[1]) * inv2,(rootdelta[2] + x[2]) * inv2,(rootdelta[3] + x[3]) * inv2]        
    r = _sqrtFp4(t,p,inv2)    
    if r is None:
      t = [t[0] - rootdelta[0],t[1] - rootdelta[1],t[2] - rootdelta[2],t[3] - rootdelta[3]]      
      r = _sqrtFp4(t,p,inv2)
      if r is None:
              t = [ - t[0], - t[1], - t[2], - t[3]]
              r = _sqrtFp4(t,p,inv2)
              if r is None:
                 t = [t[0] - rootdelta[0],t[1] - rootdelta[1],t[2] - rootdelta[2],t[3] - rootdelta[3]]
                 r = _sqrtFp4(t,p,inv2)
    if r == [0,0,0,0]:return [0,0,0,0,0,0,0,0]
    else:return r  +  _mulFp4(x[4:],_invFp4([r[0] << 1,r[1] << 1,r[2] << 1,r[3] << 1],p))

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#                                                           Arithmetic over Fp24        
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#------------------------ Multiplication over Fp24 -------------------------------------------------------------------------------------------------------------------------#
def _mulFp24(x,y):
    if (type(y) == int)or(type(y) == gmp.mpz):return [y * x[0],y * x[1],y * x[2],y * x[3],y * x[4],y * x[5],y * x[6],y * x[7],y * x[8],y * x[9],y * x[10],y * x[11],\
                                                      y * x[12],y * x[13],y * x[14],y * x[15],y * x[16],y * x[17],y * x[18],y * x[19],y * x[20],y * x[21],y * x[22],y * x[23]]
    if len(y) == 8:return _mulFp8(x[:8],y) + _mulFp8(x[8:16],y) + _mulFp8(x[16:],y) 
    else:
          t0 = _mulFp8(x[:8],y[:8])
          t1 = _mulFp8(x[8:16],y[8:16])
          t2 = _mulFp8(x[16:],y[16:])
          _ = _mulFp8([x[8] + x[16],x[9] + x[17],x[10] + x[18],x[11] + x[19],x[12] + x[20],x[13] + x[21],x[14] + x[22],x[15] + x[23]],\
                      [y[8] + y[16],y[9] + y[17],y[10] + y[18],y[11] + y[19],y[12] + y[20],y[13] + y[21],y[14] + y[22],y[15] + y[23]])
          __ = [_[0] - t1[0] - t2[0],_[1] - t1[1] - t2[1],_[2] - t1[2] - t2[2],_[3] - t1[3] - t2[3],_[4] - t1[4] - t2[4],_[5] - t1[5] - t2[5],_[6] - t1[6] - t2[6],_[7] - t1[7] - t2[7]]
          _1 = [__[6] - __[7] + t0[0],__[6] + __[7] + t0[1],__[4] + t0[2],__[5] + t0[3],__[0] + t0[4],__[1] + t0[5],__[2] + t0[6],__[3] + t0[7]]
          _ = _mulFp8([x[0] + x[8],x[1] + x[9],x[2] + x[10],x[3] + x[11],x[4] + x[12],x[5] + x[13],x[6] + x[14],x[7] + x[15]],\
                      [y[0] + y[8],y[1] + y[9],y[2] + y[10],y[3] + y[11],y[4] + y[12],y[5] + y[13],y[6] + y[14],y[7] + y[15]])
          __ = [_[0] - t0[0] - t1[0],_[1] - t0[1] - t1[1],_[2] - t0[2] - t1[2],_[3] - t0[3] - t1[3],_[4] - t0[4] - t1[4],_[5] - t0[5] - t1[5],_[6] - t0[6] - t1[6],_[7] - t0[7] - t1[7]]
          _2 = [t2[6] - t2[7] + __[0],t2[6] + t2[7] + __[1],t2[4] + __[2],t2[5] + __[3],t2[0] + __[4],t2[1] + __[5],t2[2] + __[6],t2[3] + __[7]]
          _ = _mulFp8([x[0] + x[16],x[1] + x[17],x[2] + x[18],x[3] + x[19],x[4] + x[20],x[5] + x[21],x[6] + x[22],x[7] + x[23]],\
                      [y[0] + y[16],y[1] + y[17],y[2] + y[18],y[3] + y[19],y[4] + y[20],y[5] + y[21],y[6] + y[22],y[7] + y[23]])
          _3 = [_[0] - t0[0] - t2[0] + t1[0],_[1] - t0[1] - t2[1] + t1[1],_[2] - t0[2] - t2[2] + t1[2],_[3] - t0[3] - t2[3] + t1[3],_[4] - t0[4] - t2[4] + t1[4],_[5] - t0[5] - t2[5] +\
                t1[5],_[6] - t0[6] - t2[6] + t1[6],_[7] - t0[7] - t2[7] + t1[7]]
          return _1 + _2 + _3    

#------------------------ Square over Fp24 -------------------------------------------------------------------------------------------------------------------------------#
def _sqrFp24(x):
        t0 = _sqrFp8(x[:8])
        t1 = _sqrFp8(x[8:16])
        t2 = _sqrFp8(x[16:])
        _ = _sqrFp8([x[8] + x[16],x[9] + x[17],x[10] + x[18],x[11] + x[19],\
            x[12] + x[20],x[13] + x[21],x[14] + x[22],x[15] + x[23] ])
        __ = [_[0] - t1[0] - t2[0],_[1] - t1[1] - t2[1],_[2] - t1[2] - t2[2],_[3] - t1[3] - t2[3],_[4] - t1[4] - t2[4],_[5] - t1[5] - t2[5],_[6] - t1[6] - t2[6],_[7] - t1[7] - t2[7]]
        _1 = [__[6] - __[7] + t0[0],__[6] + __[7] + t0[1],__[4] + t0[2],__[5] + t0[3],__[0] + t0[4],__[1] + t0[5],__[2] + t0[6],__[3] + t0[7]]
        _ = _sqrFp8([x[0] + x[8],x[1] + x[9],x[2] + x[10],x[3] + x[11],\
            x[4] + x[12],x[5] + x[13],x[6] + x[14],x[7] + x[15] ])
        __ = [_[0] - t0[0] - t1[0],_[1] - t0[1] - t1[1],_[2] - t0[2] - t1[2],_[3] - t0[3] - t1[3],_[4] - t0[4] - t1[4],_[5] - t0[5] - t1[5],_[6] - t0[6] - t1[6],_[7] - t0[7] - t1[7]]
        _2 = [t2[6] - t2[7] + __[0],t2[6] + t2[7] + __[1],t2[4] + __[2],t2[5] + __[3],t2[0] + __[4],t2[1] + __[5],t2[2] + __[6],t2[3] + __[7]]
        _ = _sqrFp8([x[0] + x[16],x[1] + x[17],x[2] + x[18],x[3] + x[19],\
            x[4] + x[20],x[5] + x[21],x[6] + x[22],x[7] + x[23] ])
        _3 = [_[0] - t0[0] - t2[0] + t1[0],_[1] - t0[1] - t2[1] + t1[1],_[2] - t0[2] - t2[2] + t1[2],_[3] - t0[3] - t2[3] + t1[3],_[4] - t0[4] - t2[4] + t1[4],\
            _[5] - t0[5] - t2[5] + t1[5],_[6] - t0[6] - t2[6] + t1[6],_[7] - t0[7] - t2[7] + t1[7]]
        return _1 + _2 + _3      

#------------------------ Inversion over Fp24 ---------------------------------------------------------------------------------------------------------------------------#
def _invFp24(x,p):
        _0 = _sqrFp8(x[:8])
        _ = _mulFp8(x[8:16],x[16:])
        t0 = [_0[0] - _[6] + _[7],_0[1] - _[6] - _[7],_0[2] - _[4],_0[3] - _[5],_0[4] - _[0],_0[5] - _[1],_0[6] - _[2],_0[7] - _[3]]          
        _0 = _sqrFp8(x[16:])
        _ = _mulFp8(x[:8],x[8:16])
        t1 = [_0[6] - _0[7] - _[0],_0[6] + _0[7] - _[1],_0[4] - _[2],_0[5] - _[3],_0[0] - _[4],_0[1] - _[5],_0[2] - _[6],_0[3] - _[7]]                
        _0 = _sqrFp8(x[8:16])
        _ = _mulFp8(x[:8],x[16:])
        t2 = [_0[0] - _[0],_0[1] - _[1],_0[2] - _[2],_0[3] - _[3],_0[4] - _[4],_0[5] - _[5],_0[6] - _[6],_0[7] - _[7]]                
        _0 = _mulFp8(x[:8],t0)
        _1 = _mulFp8(x[16:],t1)
        _2 = _mulFp8(x[8:16],t2)
        _ = [_1[0] + _2[0],_1[1] + _2[1],_1[2] + _2[2],_1[3] + _2[3],_1[4] + _2[4],_1[5] + _2[5],_1[6] + _2[6],_1[7] + _2[7]]        
        t3 = _invFp8([_[6] - _[7] + _0[0],_[6] + _[7] + _0[1],_[4] + _0[2],_[5] + _0[3],_[0] + _0[4],_[1] + _0[5],_[2] + _0[6],_[3] + _0[7]],p)
        return _mulFp8(t0,t3) + _mulFp8(t1,t3) + _mulFp8(t2,t3)   

#------------------------- Karabina's compressed square over cyclotomic sub-field for Fp24---------------------------------------------------------------------------------#
def _sqrcompressFp24(x):
                  t0 = _sqrFp4(x[8:12])
                  t1 = _sqrFp4(x[12:16])
                  t2 = _sqrFp4(x[16:20])
                  t3 = _sqrFp4(x[20:])
                  _0 = _sqrFp4([x[16] + x[20],x[17] + x[21],x[18] + x[22],x[19] + x[23]])
                  _ = [_0[0] - t2[0] - t3[0],_0[1] - t2[1] - t3[1],_0[2] - t2[2] - t3[2],_0[3] - t2[3] - t3[3]]
                  _0 = [3 * (_[2] - _[3]) + (x[8]<<1),3 * (_[2] + _[3]) + (x[9]<<1),3 * _[0] + (x[10]<<1),3 * _[1] + (x[11]<<1)]
                  _1 = [3 * (t3[2] - t3[3] + t2[0]) - (x[12]<<1),3 * (t3[2] + t3[3] + t2[1]) - (x[13]<<1),3 * (t3[0] + t2[2]) - (x[14]<<1),3 * (t3[1] + t2[3]) - (x[15]<<1)]
                  _2 = [3 * (t1[2] - t1[3] + t0[0]) - (x[16]<<1),3 * (t1[2] + t1[3] + t0[1]) - (x[17]<<1),3 * (t1[0] + t0[2]) - (x[18]<<1),3 * (t1[1] + t0[3]) - (x[19]<<1)]
                  _ = _sqrFp4([x[8] + x[12],x[9] + x[13],x[10] + x[14],x[11] + x[15]])
                  _3 = [3 * (_[0] - t0[0] - t1[0]) + (x[20]<<1),3 * (_[1] - t0[1] - t1[1]) + (x[21]<<1),3 * (_[2] - t0[2] - t1[2]) + (x[22]<<1),3 * (_[3] - t0[3] - t1[3]) + (x[23]<<1)]
                  return [0] * 8 + _0 + _1 + _2 + _3

#------------------------- Karabina's square decompression over cyclotomic sub-field for Fp24 ------------------------------------------------------------------------------#
def _sqrdecompressFp24(x,p):
                if x[8:16] == [0,0,0,0]:
                  _ = _mulFp4(_mulFp4(x[16:20],x[20:],id),_invFp4(x[12:16]))
                  __ = _mulFp4(x[12:16],x[16:20])
                  _ = [__[0]<<1,__[1]<<1,__[2]<<1,__[3]<<1]
                  _0 = [(_[0]<<1) - 3 * __[0],(_[1]<<1) - 3 * __[1],(_[2]<<1) - 3 * __[2],(_[3]<<1) - 3 * __[3]]
                  return [_0[6] - _0[7] + 1,_0[6] + _0[7],_0[4],_0[5],_0[0],_0[1],_0[2],_0[3]] + _ + x[8:12] + x[12:16] + x[16:20] + x[20:]  
                else:
                  _ = _sqrFp4(x[20:])                  
                  __ = [_[2] - _[3],_[2] + _[3], _[0],_[1]]
                  _ = _sqrFp4(x[16:20])                  
                  _0 = _mulFp4([__[0] + 3 * _[0] - (x[12]<<1),__[1] + 3 * _[1] - (x[13]<<1),__[2] + 3 * _[2] - (x[14]<<1),__[3] + 3 * _[3] - (x[15]<<1)],\
                              _invFp4( [x[8]<<2,x[9]<<2,x[10]<<2,x[11]<<2],p))
                  _ = _sqrFp4(_0)
                  __ = _mulFp4(x[8:12],x[20:])
                  ___ = _mulFp4(x[12:16],x[16:20])
                  _1 = [(_[0]<<1) + __[0] - 3 * ___[0],(_[1]<<1) + __[1] - 3 * ___[1],(_[2]<<1) + __[2] - 3 * ___[2],(_[3]<<1) + __[3] - 3 * ___[3]]                 
                  return [_1[2] - _1[3] + 1,_1[2] + _1[3],_1[0],_1[1]] + _0 + x[8:16] + x[16:]

#------------------------ Conjugate over Fp24 ---------------------------------------------------------------------------------------------------------------------------#
def _conjugateFp24(x):
   return [x[0],x[1],x[2],x[3], -x[4], -x[5], -x[6], -x[7], -x[8], -x[9], -x[10], - x[11],x[12],x[13],x[14],x[15],x[16],x[17],x[18],x[19], -x[20], -x[21], -x[22], -x[23]]

#-------------------------- Scott's square over cyclotomic sub-field for Fp24 --------------------------------------------------------------------------------------------#
def _unisqrFp24(x):
    t0 = _sqrFp4(x[:4])
    t1 = _sqrFp4(x[4:])
    t3 = _sqrFp4([x[0] + x[4],x[1] + x[5],x[2] + x[6],x[3] + x[7]])
    _0 = [3 * (t1[2] - t1[3] + t0[0]) - (x[0]<<1),3 * (t1[2] + t1[3] + t0[1]) - (x[1]<<1),3 * (t1[0] + t0[2]) - (x[2]<<1),3 * (t1[1] + t0[3]) - (x[3]<<1),\
        3 * (t3[0] - t0[0] - t1[0]) + (x[4]<<1),3 * (t3[1] - t0[1] - t1[1]) + (x[5]<<1),3 * (t3[2] - t0[2] - t1[2]) + (x[6]<<1),3 * (t3[3] - t0[3] - t1[3]) + (x[7]<<1)]   
    t0 = _sqrFp4(x[16:20])
    t1 = _sqrFp4(x[20:])
    t3 = _sqrFp4([x[16] + x[20],x[17] + x[21],x[18] + x[22],x[19] + x[23]])
    _1 = [3 * (t3[2] - t0[2] - t1[2] - t3[3] + t0[3] + t1[3]) + (x[8]<<1) , 3 * (t3[2] - t0[2] - t1[2] + t3[3] - t0[3] - t1[3]) + (x[9]<<1) , \
          3 * (t3[0] - t0[0] - t1[0]) + (x[10]<<1), 3 * (t3[1] - t0[1] - t1[1]) + (x[11]<<1),\
          3 * (t1[2] - t1[3] + t0[0]) - (x[12]<<1), 3 * (t1[2] + t1[3] + t0[1]) - (x[13]<<1), \
          3 * (t1[0] + t0[2]) - (x[14]<<1),3 * (t1[1] + t0[3]) - (x[15]<<1)]
    t0 = _sqrFp4(x[8:12])
    t1 = _sqrFp4(x[12:16])
    t3 = _sqrFp4([x[8] + x[12],x[9] + x[13],x[10] + x[14],x[11] + x[15]])
    _2 = [3 * (t1[2] - t1[3] + t0[0]) - (x[16]<<1),3 * (t1[2] + t1[3] + t0[1]) - (x[17]<<1),3 * (t1[0] + t0[2]) - (x[18]<<1),3 * (t1[1] + t0[3]) - (x[19]<<1),\
        3 * (t3[0] - t0[0] - t1[0]) + (x[20]<<1),3 * (t3[1] - t0[1] - t1[1]) + (x[21]<<1),3 * (t3[2] - t0[2] - t1[2]) + (x[22]<<1),3 * (t3[3] - t0[3] - t1[3]) + (x[23]<<1)]    
    return _0 + _1 + _2  


#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#                                                           Arithmetic over Fp48        
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#------------------------ Multiplication over Fp48 -------------------------------------------------------------------------------------------------------------------------#
def _mulFp48(x,y):  
        if (type(y) == int)or(type(y) == gmp.mpz):return [y * x[i] for i in range(48)]
        else :     
          _0 =  _mulFp24(x[:24],y[:24])
          _1 =  _mulFp24(x[24:],y[24:])
          _ = [_1[22] - _1[23],_1[22] + _1[23]] + _1[20:22] + _1[16:20] + _1[:16]
          _2 =  _mulFp24([x[0] + x[24],x[1] + x[25],x[2] + x[26],x[3] + x[27],x[4] + x[28],x[5] + x[29],x[6] + x[30],x[7] + x[31],x[8] + x[32],x[9] + x[33],x[10] + x[34],\
                        x[11] + x[35],x[12] + x[36],x[13] + x[37],x[14] + x[38],x[15] + x[39],x[16] + x[40],x[17] + x[41],x[18] + x[42],x[19] + x[43],x[20] + x[44],x[21] + x[45],x[22] + x[46],x[23] + x[47]],\
                       [y[0] + y[24],y[1] + y[25],y[2] + y[26],y[3] + y[27],y[4] + y[28],y[5] + y[29],y[6] + y[30],y[7] + y[31],y[8] + y[32],y[9] + y[33],y[10] + y[34],\
                        y[11] + y[35],y[12] + y[36],y[13] + y[37],y[14] + y[38],y[15] + y[39],y[16] + y[40],y[17] + y[41],y[18] + y[42],y[19] + y[43],y[20] + y[44],y[21] + y[45],y[22] + y[46],y[23] + y[47]]) # faster than loop
          return [_[0] + _0[0],_[1] + _0[1],_[2] + _0[2],_[3] + _0[3],_[4] + _0[4],_[5] + _0[5],_[6] + _0[6],_[7] + _0[7],_[8] + _0[8],_[9] + _0[9],_[10] + _0[10],_[11] + _0[11],_[12] + _0[12],\
                  _[13] + _0[13],_[14] + _0[14],_[15] + _0[15],_[16] + _0[16],_[17] + _0[17],_[18] + _0[18],_[19] + _0[19],_[20] + _0[20],_[21] + _0[21],_[22] + _0[22],_[23] + _0[23],\
                  _2[0] - _0[0] - _1[0],_2[1] - _0[1] - _1[1],_2[2] - _0[2] - _1[2],_2[3] - _0[3] - _1[3],_2[4] - _0[4] - _1[4],_2[5] - _0[5] - _1[5],_2[6] - _0[6] - _1[6],_2[7] - _0[7] - _1[7],\
                  _2[8] - _0[8] - _1[8],_2[9] - _0[9] - _1[9],_2[10] - _0[10] - _1[10],_2[11] - _0[11] - _1[11],_2[12] - _0[12] - _1[12],_2[13] - _0[13] - _1[13],_2[14] - _0[14] - _1[14],\
                  _2[15] - _0[15] - _1[15],_2[16] - _0[16] - _1[16],_2[17] - _0[17] - _1[17],_2[18] - _0[18] - _1[18],_2[19] - _0[19] - _1[19],_2[20] - _0[20] - _1[20],_2[21] - _0[21] - \
                  _1[21],_2[22] - _0[22] - _1[22],_2[23] - _0[23] - _1[23]   ]

#------------------------ Square over Fp48 -------------------------------------------------------------------------------------------------------------------------------#
def _sqrFp48(x): 
        _0 = _sqrFp24(x[:24])
        _1 = _sqrFp24(x[24:])
        _ = [_1[22] - _1[23],_1[22] + _1[23]] + [_1[20],_1[21]] + _1[16:20] + [i for i in _1[:16]]
        _2 = _sqrFp24([x[0] + x[24],x[1] + x[25],x[2] + x[26],x[3] + x[27],x[4] + x[28],x[5] + x[29],x[6] + x[30],x[7] + x[31],x[8] + x[32],x[9] + x[33],x[10] + x[34],\
                      x[11] + x[35],x[12] + x[36],x[13] + x[37],x[14] + x[38],x[15] + x[39],x[16] + x[40],x[17] + x[41],x[18] + x[42],x[19] + x[43],x[20] + x[44],x[21] + x[45],x[22] + x[46],x[23] + x[47]])
        return [_[0] + _0[0],_[1] + _0[1],_[2] + _0[2],_[3] + _0[3],_[4] + _0[4],_[5] + _0[5],_[6] + _0[6],_[7] + _0[7],_[8] + _0[8],_[9] + _0[9],_[10] + _0[10],_[11] + _0[11],_[12] + _0[12],\
                _[13] + _0[13],_[14] + _0[14],_[15] + _0[15],_[16] + _0[16],_[17] + _0[17],_[18] + _0[18],_[19] + _0[19],_[20] + _0[20],_[21] + _0[21],_[22] + _0[22],_[23] + _0[23],\
                _2[0] - _0[0] - _1[0],_2[1] - _0[1] - _1[1],_2[2] - _0[2] - _1[2],_2[3] - _0[3] - _1[3],_2[4] - _0[4] - _1[4],_2[5] - _0[5] - _1[5],_2[6] - _0[6] - _1[6],_2[7] - _0[7] - _1[7],\
                _2[8] - _0[8] - _1[8],_2[9] - _0[9] - _1[9],_2[10] - _0[10] - _1[10],_2[11] - _0[11] - _1[11],_2[12] - _0[12] - _1[12],_2[13] - _0[13] - _1[13],_2[14] - _0[14] - _1[14],\
                _2[15] - _0[15] - _1[15],_2[16] - _0[16] - _1[16],_2[17] - _0[17] - _1[17],_2[18] - _0[18] - _1[18],_2[19] - _0[19] - _1[19],_2[20] - _0[20] - _1[20],_2[21] - _0[21] - \
                _1[21],_2[22] - _0[22] - _1[22],_2[23] - _0[23] - _1[23]   ]

#------------------------ Inversion over Fp48 ---------------------------------------------------------------------------------------------------------------------------#
def _invFp48(x,p):
        _0 = _sqrFp24(x[:24])
        _1 = _sqrFp24(x[24:])
        _ = [_1[22] - _1[23],_1[22] + _1[23],_1[20],_1[21],_1[16],_1[17],_1[18],_1[19]] + _1[:16]
        t = _invFp24([_0[0] - _[0],_0[1] - _[1],_0[2] - _[2],_0[3] - _[3],_0[4] - _[4],_0[5] - _[5],_0[6] - _[6],_0[7] - _[7],_0[8] - _[8],_0[9] - _[9],\
                    _0[10] - _[10],_0[11] - _[11],_0[12] - _[12],_0[13] - _[13],_0[14] - _[14],_0[15] - _[15],_0[16] - _[16],_0[17] - _[17],_0[18]\
                     - _[18],_0[19] - _[19],_0[20] - _[20],_0[21] - _[21],_0[22] - _[22],_0[23] - _[23]],p)
        _ = _mulFp24(x[24:],t)
        return _mulFp24(x[:24],t) + [ - _[0],-_[1],-_[2],-_[3],-_[4],-_[5],-_[6],-_[7],-_[8],-_[9],-_[10],-_[11],\
                            - _[12],-_[13],-_[14],-_[15],-_[16],-_[17],-_[18],-_[19],-_[20],-_[21],-_[22],-_[23]]

#------------------------- Karabina's compressed square over cyclotomic sub-field for Fp48---------------------------------------------------------------------------------#
def _sqrcompressFp48(x):
            t0 = _sqrFp8(x[8:16]) 
            t1 = _sqrFp8(x[40:]) 
            t3 = _sqrFp8(x[24:32]) 
            t4 = _sqrFp8(x[16:24]) 
            _0 = [3 * (t4[6] - t4[7] + t3[0]) - (x[8] << 1),3 * (t4[6] + t4[7] + t3[1]) - (x[9] << 1),3 * (t4[4] + t3[2]) - (x[10] << 1),3 * (t4[5] + t3[3]) - (x[11] << 1),\
                3 * (t4[0] + t3[4]) - (x[12] << 1),3 * (t4[1] + t3[5]) - (x[13] << 1),3 * (t4[2] + t3[6]) - (x[14] << 1),3 * (t4[3] + t3[7]) - (x[15] << 1)] 
            _1 = [3 * (t1[6] - t1[7] + t0[0]) - (x[16] << 1),3 * (t1[6] + t1[7] + t0[1]) - (x[17] << 1),3 * (t1[4] + t0[2]) - (x[18] << 1),3 * (t1[5] + t0[3]) - (x[19] << 1),\
                3 * (t1[0] + t0[4]) - (x[20] << 1),3 * (t1[1] + t0[5]) - (x[21] << 1),3 * (t1[2] + t0[6]) - (x[22] << 1),3 * (t1[3] + t0[7]) - (x[23] << 1)] 
            _2 = _sqrFp8([x[8] + x[40],x[9] + x[41],x[10] + x[42],x[11] + x[43],x[12] + x[44],x[13] + x[45],x[14] + x[46],x[15] + x[47]])          
            _2 = [3 * (_2[6] - t0[6] - t1[6] - _2[7] + t0[7] + t1[7]) + (x[24] << 1),3 * (_2[6] - t0[6] - t1[6] + _2[7] - t0[7] - t1[7]) + \
                  (x[25] << 1),3 * (_2[4] - t0[4] - t1[4]) + (x[26] << 1),3 * (_2[5] - t0[5] - t1[5]) + (x[27] << 1),\
                3 * (_2[0] - t0[0] - t1[0]) + (x[28] << 1),3 * (_2[1] - t0[1] - t1[1]) + (x[29] << 1),3 * (_2[2] - t0[2] - t1[2]) + (x[30] << 1),3 * (_2[3] - t0[3] - t1[3]) + (x[31] << 1)]
            _3 = _sqrFp8([x[16] + x[24],x[17] + x[25],x[18] + x[26],x[19] + x[27],x[20] + x[28],x[21] + x[29],x[22] + x[30],x[23] + x[31]]) 
            _3 = [3 * (_3[0] - t3[0] - t4[0]) + (x[40] << 1),3 * (_3[1] - t3[1] - t4[1]) + (x[41] << 1),3 * (_3[2] - t3[2] - t4[2]) + (x[42] << 1),3 * (_3[3] - t3[3] - t4[3]) + (x[43] << 1)\
               ,3 * (_3[4] - t3[4] - t4[4]) + (x[44] << 1),3 * (_3[5] - t3[5] - t4[5]) + (x[45] << 1),3 * (_3[6] - t3[6] - t4[6]) + (x[46] << 1),3 * (_3[7] - t3[7] - t4[7]) + (x[47] << 1)]
            return [0] * 8 + _0 + _1 + _2 + [0] * 8 + _3

#------------------------- Karabina's square decompression over cyclotomic sub-field for Fp48 ------------------------------------------------------------------------------#
def _sqrdecompressFp48(x,p):
                if x[24:32] == [0] * 8:
                  _0 = _sqrFp8(x[32:40])
                  _1 = _mulFp8(x[16:24],x[8:16])
                  _1 = [(_0[0] << 1) - 3 * (_1[6] - _1[7]) + 1,(_0[1] << 1) - 3 * (_1[6] + _1[7]),(_0[2] << 1) - 3 * (_1[4]),(_0[3] << 1) - 3 * (_1[5]),(_0[4] << 1) - 3 * (_1[0]),(_0[5] << 1) - 3 * (_1[1]),\
                      (_0[6] << 1) - 3 * (_1[2]),(_0[7] << 1) - 3 * (_1[3])]
                  _2 = _mulFp8(x[8:16],x[40:])
                  _2 = _mulFp8(_2,_invFp8(x[16:24]))      
                  return _1 + x[8:32] + [2 * i for i in _2] + x[40:]
                else:
                  _0 = _sqrFp8(x[8:16])
                  _1 = _sqrFp8(x[40:])
                  rbb = _mulFp8([_1[6] - _1[7] + 3 * _0[0] - (x[16] << 1),_1[6] + _1[7] + 3 * _0[1] - (x[17] << 1),_1[4] + 3 * _0[2] - (x[18] << 1),_1[5] + 3 * _0[3] - (x[19] << 1),_1[0] + 3 * _0[4] - (x[20] << 1),\
                                  _1[1] + 3 * _0[5] - (x[21] << 1),_1[2] + 3 * _0[6] - (x[22] << 1),_1[3] + 3 * _0[7] - (x[23] << 1)],\
                      _invFp8([x[24] << 2,x[25] << 2,x[26] << 2,x[27] << 2,x[28] << 2,x[29] << 2,x[30] << 2,x[31] << 2],p))
                  _0 = _sqrFp8(rbb)
                  _1 = _mulFp8(x[24:32],x[40:])
                  _2 = _mulFp8(x[8:16],x[16:24])
                  _0 = [(_0[6] << 1) + _1[6] - 3 * _2[6] - (_0[7] << 1) - _1[7] + 3 * _2[7] + 1,(_0[6] << 1) + _1[6] - 3 * _2[6] + (_0[7] << 1) + _1[7] - 3 * _2[7]] + [(_0[4] << 1) + _1[4] - 3 * _2[4],\
                      (_0[5] << 1) + _1[5] - 3 * _2[5]] + [(_0[0] << 1) + _1[0] - 3 * _2[0],(_0[1] << 1) + _1[1] - 3 * _2[1],(_0[2] << 1) + _1[2] - 3 * _2[2],(_0[3] << 1) + _1[3] - 3 * _2[3]] 
                  return _0 + x[8:32] + rbb + x[40:]
                
#-------------------------- Scott's square over cyclotomic sub-field for Fp48 --------------------------------------------------------------------------------------------#
def _unisqrFp48(x):    
    # Adapted Scott's square for 2 - 3 - 2 construction from "Choosing and generating parameters for low level pairing implementation on BN curves" section 7.2.2
    # https://eprint.iacr.org/2015/1212 
    b02  =  _sqrFp8(x[:8])
    b22  =  _sqrFp8(x[8:16])
    b42  =  _sqrFp8(x[16:24])
    b12  =  _sqrFp8(x[24:32])
    b32  =  _sqrFp8(x[32:40])
    b52  =  _sqrFp8(x[40:48])
    b2pb5_2  =  _sqrFp8([ x[i + 8]  +  x[i + 40] for i in range(8)])
    b0pb3_2  =  _sqrFp8([ x[i]  +  x[i + 32] for i in range(8)])
    b4pb1_2  =  _sqrFp8([ x[i + 16]  +  x[i + 24] for i in range(8)])
    _0  =  [b32[6] - b32[7],b32[6] + b32[7],b32[4],b32[5],b32[0],b32[1],b32[2],b32[3]]  # w * b3^2
    _1  =  [b42[6] - b42[7],b42[6] + b42[7],b42[4],b42[5],b42[0],b42[1],b42[2],b42[3]]  # w * b4^2
    _2  =  [b52[6] - b52[7],b52[6] + b52[7],b52[4],b52[5],b52[0],b52[1],b52[2],b52[3]]  # w * b5^2
    _  =  [3 * (b2pb5_2[i]  -  b22[i]  -  b52[i]) for i in range(8) ]   # 3 * (b2 + b5)^2 - b2^2 - b3^2
    B0  =  [3 * (_0[i]  +  b02[i])  -  (x[i] << 1) for i in range(8)]
    B2 =  [3 * (_1[i]  +  b12[i])  -  (x[i + 8] << 1) for i in range(8)]
    B4  =  [3 * (_2[i]  +  b22[i])  -  (x[i + 16] << 1) for i in range(8)]
    B1  =  [_[6] - _[7] + (x[24] << 1),_[6] + _[7] + (x[25] << 1),_[4] + (x[26] << 1),_[5] + (x[27] << 1),_[0] + (x[28] << 1),_[1] + (x[29] << 1),_[2] + (x[30] << 1),_[3] + (x[31] << 1)]
    B3  =  [3 * (b0pb3_2[i]  -  b02[i]  -  b32[i])  +  (x[32 + i] << 1) for i in range(8) ]
    B5  =  [3 * (b4pb1_2[i]  -  b42[i]  -  b12[i])  +  (x[40 + i] << 1) for i in range(8) ]    
    return B0  +  B2  +  B4  +  B1  +  B3  +  B5

#------------------------ Conjugate over Fp48 ---------------------------------------------------------------------------------------------------------------------------#
def _conjugateFp48(x):
   return [x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9],x[10],x[11],x[12],x[13],x[14],x[15],x[16],x[17],x[18],x[19],x[20],x[21],x[22],x[23] ,\
            - x[24],-x[25],-x[26],-x[27],-x[28],-x[29],-x[30],-x[31],-x[32],-x[33],-x[34],-x[35],-x[36],-x[37],-x[38],-x[39],-x[40],-x[41],-x[42],-x[43],-x[44],-x[45],-x[46],-x[47]]

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#                                              Sparse multiplication arithmetic over Fp12/24/48 for Miller-loop        
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
def _sparse_mulFp6(x,y):          # y is sparse Fp6 :(y0+y1*u)+(y2+y3*u)*v , (y4=y5=0)
            _0 , _1 = x[0] * y[0],x[1] * y[1]
            t0 = [_0 - _1,((x[0] + x[1]) * (y0py1:=y[0] + y[1]) - _0 - _1)]

            _0 , _1 = x[2] * y[2],x[3] * y[3]
            t1 = [_0 - _1,((x[2] + x[3]) * (y2py3:=y[2] + y[3]) - _0 - _1)]

            _0 = [x[2] + x[4],x[3] + x[5]]
            __0, __1 = _0[0] * y[2],_0[1] * y[3]
            _ = [(__0 - __1 - t1[0]),((_0[0] + _0[1]) * (y2py3) -__0 - __1 - t1[1])]
            _res = [(_[0] - _[1]) + t0[0],(_[0] +_[1]) + t0[1]]

            _0 , _1 = [x[0] + x[2],x[1] + x[3]],[y[0] + y[2],y[1] + y[3]]
            __0 , __1 = _0[0] * _1[0],_0[1] * _1[1]
            _res = _res + [__0 -__1 - t0[0] - t1[0],(_0[0] + _0[1]) * (_1[0] + _1[1]) - __0 - __1 - t0[1] - t1[1]]

            _0 = [x[0] + x[4],x[1] + x[5]]
            __0 , __1 = _0[0] * y[0],_0[1] * y[1]
            _res = _res + [__0 - __1 - t0[0] + t1[0],(_0[0] + _0[1]) * (y0py1) -__0 - __1 - t0[1] + t1[1]]           
            return _res

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
def _sparse_mulFp12(x,y):
    # Multiplication with a sparse Fp12 according to M - type twiste   
      t0 = _sparse_mulFp6(x[:6],y)
      t1 = _sparse_mulFp6([x[0] + x[6],x[1] + x[7],x[2] + x[8],x[3] + x[9],x[4] + x[10],x[5] + x[11]],[y[0],y[1],y[2]  +  1,y[3]])
      return [(x[8] - x[9]) + t0[0],(x[8] + x[9]) + t0[1],(x[10] - x[11] + t0[2]),(x[10] + x[11] + t0[3]),x[6] + t0[4],x[7] + t0[5]] + \
             [t1[0] - t0[0] - x[10] + x[11],t1[1] - t0[1] - x[10] - x[11],t1[2] - t0[2] - x[6],t1[3] - t0[3] - x[7],t1[4] - t0[4] - x[8],t1[5] - t0[5] - x[9]]

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
def _sparseMulFp8(x,y):   # y is an Fp4
      #       optimized implementing of _mulFp4(x[:4],y)+_mulFp4(x[4:],y)
      y0py1 = (y[0]+y[1])
      y2py3 = (y[2]+y[3])
      y0py2 = (y[0]+y[2])
      y1py3 = (y[1]+y[3])
      ally  = y1py3 + y0py2

      _0 ,_1 = x[0] * y[0], x[1] * y[1]
      _t0 = [_0 -_1,((x[0] + x[1]) * y0py1 - _0 - _1)]
      _0 ,_1 = x[2] * y[2], x[3] * y[3]
      _t1 = [_0 -_1,((x[2] + x[3]) * y2py3 - _0 - _1)]
      _0 ,_1 = (x[0] + x[2]),(x[1] + x[3])
      _sx, _0,_1 =_0 + _1, _0 * y0py2, _1 * y1py3
      _res = [(_t0[0]+(_t1[0]-_t1[1])),(_t0[1]+(_t1[0]+_t1[1])), _0-_1-_t0[0]-_t1[0],(_sx* ally -_0-_1-_t0[1]-_t1[1])] 
      
      _0 ,_1 = x[4] * y[0], x[5] * y[1]
      _t0 = [_0 -_1,((x[4] + x[5]) * y0py1 - _0 - _1)]
      _0 ,_1 = x[6] * y[2], x[7] * y[3]
      _t1 = [_0 -_1,((x[6] + x[7]) * y2py3 - _0 - _1)]
      _0 ,_1 = (x[4] + x[6]),(x[5] + x[7])
      _sx, _0,_1 =_0 + _1, _0 * y0py2, _1 * y1py3
      return _res + [(_t0[0]+(_t1[0]-_t1[1])),(_t0[1]+(_t1[0]+_t1[1])), _0-_1-_t0[0]-_t1[0],(_sx* ally -_0-_1-_t0[1]-_t1[1])] 

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
def _sparseMulFp24(x,y):
          t0 = _sparseMulFp8(x[:8],y[:4])
          t0 = [x[0] + t0[6] - t0[7],x[1] + t0[6] + t0[7],x[2] + t0[4],x[3] + t0[5],x[4] + t0[0],x[5] + t0[1],x[6] + t0[2],x[7] + t0[3]]
          _1 = _sparseMulFp8(x[16:24],y[4:])
          _1 = [_1[6] - _1[7] + t0[0],_1[6] + _1[7] + t0[1],_1[4] + t0[2],_1[5] + t0[3],_1[0] + t0[4],_1[1] + t0[5],_1[2] + t0[6],_1[3] + t0[7]]
          t1 = _sparseMulFp8([x[6] + x[14] - x[7] - x[15],x[6] + x[14] + x[7] + x[15],x[4] + x[12],x[5] + x[13],x[0] + x[8],x[1] + x[9],x[2] + x[10],x[3] + x[11]],y[:4])
          _2 = _sparseMulFp8(x[:8],[1 + y[4],y[5],y[6],y[7]])         
          _2 = [_2[i]  +  t1[i]  -  t0[i]  +  x[8 + i] for i in range(8)]        
          t1 = _sparseMulFp8(x[8:16],y[4:])
          _  = [x[i]  +  x[16 + i] for i in range(8)]
          _3 = [_[6] - _[7],_[6] + _[7],_[4],_[5],_[0],_[1],_[2],_[3]]
          _3 = _sparseMulFp8(_3,y[:4])
          _3 = [_3[i]  +  _[i]  -  t0[i]  +  t1[i] for i in range(8)]
          return _1 + _2 + _3  

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
def _sparseMulFp24_48(x,y):
          t0 = _mulFp8(x[:8],y[:8])
          t1 = _mulFp8(x[16:24],y[8:16])
          t2 = _mulFp8(x[8:16],y[8:16])
          t3 = _mulFp8([x[0] + x[8],x[1] + x[9],x[2] + x[10],x[3] + x[11],x[4] + x[12],x[5] + x[13],x[6] + x[14],x[7] + x[15]],\
                       [y[0] + y[8],y[1] + y[9],y[2] + y[10],y[3] + y[11],y[4] + y[12],y[5] + y[13],y[6] + y[14],y[7] + y[15]])
          _res = [t1[6] - t1[7] + t0[0],t1[6] + t1[7] + t0[1],t1[4] + t0[2],t1[5] + t0[3],t1[0] + t0[4],t1[1] + t0[5],t1[2] + t0[6],t1[3] + t0[7]]\
                  +  [t3[i]  -  t0[i]  -  t2[i] for i in range(8)]
          t3 = _mulFp8(x[16:24],y[:8])
          _res = _res  +  [t3[i]  +  t2[i] for i in range(8)]
          return _res    

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
def _sparseMulFp48(x,y):    
          _0 = _sparseMulFp24_48(x[:24],y[:16])
          _1 = _sparseMulFp24_48(x[24:],y[:16])          
          _2 = [x[22] - x[23],x[22] + x[23],x[20],x[21],x[16],x[17],x[18],x[19]]  +  x[:16]
          _3 = [x[38] - x[39],x[38] + x[39],x[36],x[37],x[32],x[33],x[34],x[35],x[46] - x[47],x[46] + x[47],x[44],x[45],x[40],x[41],x[42],x[43]]  +  x[24:32]
          return [_0[i]  +  _3[i] for i in range(24)]  +  [_1[i]  +  _2[i] for i in range(24)]
